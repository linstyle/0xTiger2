
明日:4.23
对网络层的封装需求:
buffer和方法分开
加入一个心跳协议----------------------最后
加入参数，指定创建阻塞还是非阻塞套接字


4月28日
网络层和逻辑层中间传递的标识
--------------------------------------------------------------------------
多对象的:	网络的对象池+逻辑层的数组池.互相开放CLOSE接口.同时配合IOCP
单、少数对象的:	{}
单: 就是对应一份全局数据
少数:
如果非IOCP类的，都是以套接字值进行传递.也就是说需要一个
套接值---map---逻辑对象地址  的数据结构,同时也可以包含单个
{
   取得响应的套接字
   find逻辑对象 hash
   返回对象{逻辑对象+网络对象+other}
}


交互
网络层响应->出错->find逻辑对象->一起close
逻辑对象执行->出错->一起close



模块包含层次
网络结构.h-->Close()
      find.cpp
对象{网络结构，逻辑结构}


执行逻辑
accept: 网络结构.open   逻辑结构.open
recv:   find()


5月6日
协议跳转修改
0，helloworld

	int ServerLogin(MsgBaseHead *pMsgBase, CUserBridge* pUserBridge)
	{
		跳转到__BinLogin
	}
	int __ServerBinLogin( MsgBaseHead *pMsgBase, CUserBridge* pUserBridge );
	int __ServerDpcLogin( MsgBaseHead *pMsgBase, CUserBridge* pUserBridge );



邮局上的路由格式
--------------------------------------------------------------------------
数据转发，对于邮局来说，数据都是透明化的。他可以保存每个逻辑服务器的对应关系，但是转发时
并不应该从这些关系中进行获取

C -> 查找identi ->转发
B -> socket  -> 转发

路由关系:
服务器管理数组={0，1，3，4，5，6}；
场景对应服务器管理数组{0{1-5}, 1{6-10}, 2{11-15}......}
玩家对应场景服务器 { 1{1--n}, 2{n+1--n+n}.... }


C结构
navigation
{
   nIdenti;			//服务器管理数组对应下标
   
}

Bin结构,放置于协议头
nMRoleSocket;		//玩家套接字接口



5月7日
--------------------------------------------------------------------------
Server收到连接，-> (携带Socket) Bin
Bin记录Socket， -> (携带MRole编号) Server
Server记录

无心跳包
Server的MRole结构
{
	int nIdentiBin; nIdentiDpc;
	int nBinMRole, 唯一校验编号;
}

Bin的MRole结构
{
	int nServerMRoleSocket;
}
转发
C->Server->Bin
send(nIdentiBin, nBinMRole编号);

Bin->Server->C
send(nServerMRoleSocket);

关闭
Server主动Close->Bin被动Close
Bin主动Close->Server被动Close


有心跳包
Server主动Close, 若干秒后Bin主动Close
Bin主动Close,    若干秒后Server主动Close.



Scene管理
--------------------------------------------------------------------------
SceneManager: 场景个数,配置文件中读取，编号，人数

Scene:编号，人数MRole  <参数提供>


5月11日
--------------------------------------------------------------------------
设计框架重新制定
在线的信息上加入“线”的标识
邮局服务器也需要重新修改组织架构

网关
玩家结构
{
	Bin中的资源编号
}

g_map_relation
一个完整的树形结构
线:
  BIN服务器
  					图
      				玩家
			          玩家在哪个网关
			          玩家在那个网关的套接字
			          玩家在那个网关的资源编号
			          玩家在那个网关的唯一标识(用来验证是否一，可以暂时不用)
          
Bin
玩家结构
{
	玩家在哪个网关
	玩家在那个网关的套接字
	玩家在那个网关的资源编号
	玩家在那个网关的唯一标识(用来验证是否一，可以暂时不用)
} 

玩家场景结构
{
	完整映射图
}

初始化过程:
C---(连接)-->P, TA{在哪个网关，玩家在网关上的套接字，玩家在网关上的资源编号}
P---(登陆)---g, 存储TA
g---(数据库验证等工作)--成功,同步
g---(发送给map, P)---存储场景信息,因为是同步，所以TA和场景信息对应绑定
map。。。等待数据库发送完整人物信息，向g请求TA信息，然后存储TA，玩家游戏信息，
map全部创建完成后，返回登陆成功消息，并且携带玩家的资源编号返回给邮局服务器



跨图消息:
Bin把该条消息转发给g
g通过消息中的玩家ID找到玩家的路由信息
通过路由信息转发给网关

网关收到后，根据携带的bin序列，查询到后发送


5月14日
-------------------------------------------------------------------------------
scene中MROLE的资源管理
有个公共的MROLE池, 怪物池。

单线程
scene中的MROLE以链表形式存储单独的MROLE池地址
scene中的ROLE以链表形式存储单独的ROLE池地址

5月17日
-------------------------------------------------------------------------------
几个询问的协议
1.传递第一次登陆协议， P->g的时候，传递IN POSTOFFICE SERVER
	2.g向数据库验证，取回轻量的场景信息，和IN POSTOFFICE SERVER绑定
3.map收到建立人物请求信息后,向g请求TA信息，然后存储IN POSTOFFICE SERVER


p:各逻辑服务器的对应关系。初始化时即确认
g:在邮局服务器的消息，<游戏服务器的详细信息映射图>。
  在第一回登陆时确认，登陆验证时从服务器返回轻量的场景信息
m:在p的消息，在g的信息(每个角色ID的资源编号,一个很小巧的映射)
  建立人物后，向g请求p+g信息
	无可避免的查询一次hash， 线.场景.人物
	
步骤一：
p:各逻辑服务器的对应关系。初始化时即确认；各个客户端对应的资源编号；
	
m:在p的消息，
  
	
	
	

5月19日
-------------------------------------------------------------------------------
初始化的方法:

1.p->g,g去db验证
2.db通过，返回轻量数据给g,全部数据给m
3.m在一个临时队列里建立该角色，并且等待g数据的资源更新
4.g返回该角色资源编号、网关编号给m
5.m临时队列里条件满足，将该角色资源编号给网关
6.开始通讯


出错关闭的方法1:主动性关闭
客户端主动关闭
p->m, m内部关闭

客户端无响应
网关超时检测
p->m, m内部关闭

m服务器内部出错
m内部关闭, p内部关闭

当m内部关闭时，同时更新g关系服务器


第一回测试方案，假设登陆成功的情况下
c->p->m, c发送一个消息给m，m处理后转发给c

c连接成功后，p发送P1给m,并且写死m的信息(0线0台逻辑机0号资源)

m收到后，从中获取c在p中的资源信息,并且建立角色，添加到场景(0线0场景)


c发送一个测试协议2，m处理后转发


P1:
	玩家在哪个网关 0
	玩家在那个网关的套接字
	玩家在那个网关的资源编号 
	玩家在那个网关的唯一标识(用来验证是否一，可以暂时不用)


接收缓冲区 = 原大小+各部件协议头部大小
协议包的再次封装

网关头部
class MsgPostofficeHead
{
public:
		int nSizeOfMsg;
		int nResIdentiInBin;
		
		MsgPostofficeHead()
		{
			
		}
};


5月20日
-------------------------------------------------------------------------------
几种资源编号:

在哪台机器上		：nInXXXWhich;
在对象池中的编号：nInXXXRes;
套接字编号			：nInXXXSocket;

去除原来的identi,在In前缀中默认的语意即identi


续内部包封装：
因为要携带一些内部信息的资源结构，而又不想对正式的包体进行添加。
比如从网关到BIN的包，携带一个PostHead；从BIN到网关的包，携带一个BinHead;

1。能够识别包的来源,是裸包还是Pack包;根据用户等级
	 如果是BIN发包，写死有个头部,但是不在协议体里表现出来
	 
2。能够脱掉包头，取到有用信息，然后向外转发
3。在包的大小上能做有控制
4。


class MsgPostHead
{
public:
	

};

buffer[];  nLenPostHead

PackToPost()
{
	取得MRole对象，获取信息
	MsgPostHead *pPostHead = (MsgPostHead*)buffer;
	//...
	//...
	
	char *pBuffer = buffer+=nLenPostHead
	return pBuffer;
}

Send()
{
	char *pBuffer = PackToPost();
	//....
}


UnPackToPost()
{
	根据buffer取到MROLE信息；
	return pBuffer+nLenPostHead;
}

Recv()
{
	char *pBuffer = UnPackToPost();
	//......
}



5月26日
-------------------------------------------------------------------------------
更新 2，0
客户端第一条 2，1
。。。第二条 2，2

客户端发送，P收到后发更新消息给B，B进行更新
客户端发送消息，P收到后转发给B，B收到后进行解析处理
B转发给P，并且带上包尾；P拆离包尾，取出目的地套接字，然后发送



目录
-------------------------------------------------------------------------------
Client



Server
   Bin
   Src
      Route
      Server
      Bin
      CommonLib
          


